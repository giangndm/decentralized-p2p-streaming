# RFC for Decentralized Streaming Protocol

- Version: unversioned
- Last updated: 2024-01-29
- Author: giang.ndm@gmail.com (https://github.com/giangndm)
- Status: Draft

## 1. Introduction

### 1.1 Purpose

Today, streaming applications are widely used, from video conferences to live streaming, etc. However, most of them use centralized servers to stream data to clients, which raises privacy and security concerns and incurs high server costs. Therefore, we need a decentralized streaming protocol to address these issues.

In this document, we propose a solution for creating a decentralized streaming protocol that maintains the latency and quality of streaming while reducing the cost of streaming service to zero if we have enough users.

### 1.2 Scope

This protocol is intended for creating decentralized streaming applications such as video conferences, live streaming, etc., which support audio and video streaming as well as chat channels.

## 2. Terminology

In this document, we will use the following terms:

- **Node**: The node in the network.
- **Connection**: The connection between 2 nodes.
- **Publisher**: The node that streams data to other nodes.
- **Subscriber**: The node that receives data from the publisher.
- **Relay**: The node used to relay data from the publisher to the subscriber.
- **Neighbour**: The node connected to another node.
- **Best next hop**: The best neighbour to connect to the publisher.
- **Channel**: The channel used to stream data.
- **Stream**: Audio or video stream.
- **Packet**: Audio or video packet.

## 3. Protocol Overview

Assuming we already have a peer-to-peer (p2p) network that connects all nodes together without any partition, we can use any network topology such as structured or unstructured, etc. Some network topologies like Kademlia, Chord, etc. can be used to create a p2p network.

### 3.1 Connection Cost Function

The connection cost function is used to calculate the cost of the connection between two nodes. The cost is used to determine the best next hop to connect to the publisher.

The cost function is calculated based on factors such as latency, packet loss, jitter, etc. Each node periodically pings its neighbors to gather these metrics. The cost function is then applied, and the resulting costs are saved in a metrics table for each node:

| Neighbour | Cost |
|-----------|------|
| Node01    | 10   |
| Node02    | 15   |
| Node01    | 20   |

It's important to note that there can be multiple connections between two nodes, which can use different protocols like TCP, UDP, WebRTC, etc.

### 3.2 Router table

The router table is used to store information about the best next hop to connect to the publisher. Each node maintains its own router table, which contains the following columns:

| Channel   | Next hop | Cost |       Path       |
|-----------|----------|------|------------------|
| Channel01 | Node01   | 10   | [Node01, Node02] |
| Channel02 | Node02   | 15   | [Node02]         |
| Channel03 | Node03   | 20   | [Node03, Node02] |

In the table, each row represents a channel, and the corresponding columns provide information about the best next hop node to reach the publisher for that channel, the cost associated with the connection, and the path taken to reach the publisher.

The router table is periodically synchronized with all neighboring nodes to ensure that each node has the most up-to-date information about the network topology.

### 3.3 Router sync

The router table is synchronized with all neighbors periodically, with a default sync period of 1 second.

The sync message is generated by the algorithm below:

```
For each neighbor connection:
    Create a new SYNC_MSG
    For each channel in the router table:
        Select the best next hop for that channel, excluding the neighbor in path
        Append (channel, next_hop, connection, cost) to SYNC_MSG
    End for
    Send SYNC_MSG to the neighbor
End for
```

### 3.4 Fast path prove

To prove the correctness of the network state, we start with an initial incorrect state and demonstrate that the network state will eventually become correct after several synchronization cycles.

We begin with a root node, which acts as the publisher and has only one rule: a loopback connection with a cost of 0. The root node sends a sync message to all its neighbors. The neighbors receive the sync message and update their router tables. At this point, all direct neighbors have the correct router rule for a direct connection to the root node.

Next, each direct neighbor of the root node continues to sync their router tables with all their other neighbors. This synchronization process spreads throughout the network, ensuring that all nodes are eventually synced after several sync cycles.

By following this logic for building the sync messages, we also prevent network loops from occurring.

### 3.5 Stream data flow

Using the router table mentioned above, when a node subscribes to a channel, it sends a SUB request to itself. Upon receiving the SUB command, the node checks if it already has a RELAY for that channel. If it does, it simply adds the sender as a relay destination. If it doesn't have a RELAY for that channel, it creates a new RELAY and sends the SUB request to the next hop.

This approach allows us to build an optimal tree of RELAY nodes for each channel.

To avoid wasting bandwidth, each RELAY periodically sends SUB requests to the next hop if it still has subscribers. If a RELAY no longer has any subscribers, it sends an UNSUB request to the next hop and removes itself. Additionally, a RELAY removes a destination if it doesn't receive any SUB requests from that destination within a certain timeout period.

## 4. Protocol Details

### 4.1 Protocol Messages

To adapt to different programming languages, we will use protobuf to define protocol messages.

SYNC_MSG:
```
```

SUB:
```
```

UNSUB:
```
```

DATA:
```
```

### 4.2 Parameters

| Parameter | Description | Default |
|-----------|-------------|---------|
| SYNC_INTERVAL | Sync route interval |    1s     |
| SUB_INTERVAL  | Re-sub interval  |    1s     |
| SUB_TIMEOUT  | Subscribe timeout  |    5s     |

## 5. Performance Considerations

Discuss any potential performance issues and how they can be mitigated.

## 6. Security Considerations

Discuss any potential security issues and how they can be mitigated.

## 7. References

List any references or resources used in the creation of this document.

## 8. Acknowledgements

We thank the following people and organization for their contributions and support to this project:

OWS Vietnam,
Bluesea Network,
8xFF Foundation,
